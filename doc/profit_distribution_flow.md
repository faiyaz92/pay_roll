# Profit Distribution Flow - Payment Calculations & Processing

## Overview
This document outlines the complete profit distribution flow and payment calculations for **Section 5 individual vehicle buttons** in `FinancialAccountsTab.tsx` (GST, Service Charge, Partner Payment, Owner Payment). All payments follow the same transaction pattern with different calculation formulas.

**IMPORTANT**: This flow specifically covers the individual payment buttons that appear on each vehicle card in Section 5. The bulk payment buttons at the top of the section follow similar logic but operate across multiple vehicles.

## Payment Types and Firestore Transaction Types

### Complete AccountingTransaction Interface
```typescript
interface AccountingTransaction {
  id: string;                    // Auto-generated Firestore document ID
  vehicleId: string;             // Reference to vehicle document ID
  type: 'gst_payment' | 'service_charge' | 'partner_payment' | 'owner_payment';
  amount: number;                // Payment amount in rupees
  month: string;                 // Period string (e.g., "2025-11", "2025-Q4", "2025")
  description: string;           // Human-readable description of the transaction
  status: 'pending' | 'completed' | 'reversed';  // Transaction status
  createdAt: string;             // ISO timestamp when transaction was created
  completedAt?: string;          // ISO timestamp when transaction was completed
  reversedAt?: string;           // ISO timestamp when transaction was reversed (optional)
}
```

### All Payment Types and Their Firestore Types

| Payment Type | Firestore Type | Description | Amount Source |
|-------------|----------------|-------------|---------------|
| **GST Payment** | `'gst_payment'` | 4% Government tax on profits | `vehicleInfo.gstAmount` |
| **Service Charge** | `'service_charge'` | Company fee on partner vehicles | `vehicleInfo.serviceCharge` |
| **Partner Payment** | `'partner_payment'` | Partner's share of profits | `vehicleInfo.partnerShare` |
| **Owner Payment** | `'owner_payment'` | Owner's payment (both partner and company vehicles) | `vehicleInfo.ownerPayment` |

### Transaction Status Values
- `'pending'`: Transaction initiated but not yet processed
- `'completed'`: Transaction successfully processed
- `'reversed'`: Transaction cancelled/undone (includes `reversedAt` timestamp)

### Firestore Collection Path
**Collection**: `Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/accountingTransactions`

### Sample Transaction Documents

#### GST Payment Transaction
```json
{
  "id": "auto-generated-firestore-id",
  "vehicleId": "vehicle-doc-id-123",
  "type": "gst_payment",
  "amount": 2400,
  "month": "2025-11",
  "description": "GST Payment for MH12AB1234 - November 2025",
  "status": "completed",
  "createdAt": "2025-11-15T10:30:00.000Z",
  "completedAt": "2025-11-15T10:30:00.000Z"
}
```

#### Service Charge Transaction
```json
{
  "id": "auto-generated-firestore-id",
  "vehicleId": "vehicle-doc-id-456", 
  "type": "service_charge",
  "amount": 5000,
  "month": "2025-Q4",
  "description": "Service Charge for MH12CD5678 - Q4 2025",
  "status": "completed",
  "createdAt": "2025-11-15T10:35:00.000Z",
  "completedAt": "2025-11-15T10:35:00.000Z"
}
```

#### Partner Payment Transaction
```json
{
  "id": "auto-generated-firestore-id",
  "vehicleId": "vehicle-doc-id-789",
  "type": "partner_payment",
  "amount": 15000,
  "month": "2025-10",
  "description": "Partner Payment for MH12EF9012 - October 2025",
  "status": "completed",
  "createdAt": "2025-11-10T09:00:00.000Z",
  "completedAt": "2025-11-10T09:00:00.000Z"
}
```

#### Owner Payment Transaction (Consolidated)
```json
{
  "id": "auto-generated-firestore-id",
  "vehicleId": "vehicle-doc-id-101",
  "type": "owner_payment",
  "amount": 25000,
  "month": "2025-11",
  "description": "Owner Payment for MH12GH3456 - November 2025",
  "status": "completed",
  "createdAt": "2025-11-15T11:00:00.000Z",
  "completedAt": "2025-11-15T11:00:00.000Z"
}
```

#### Reversed Transaction Example
```json
{
  "id": "auto-generated-firestore-id",
  "vehicleId": "vehicle-doc-id-789",
  "type": "partner_payment", 
  "amount": 15000,
  "month": "2025-10",
  "description": "Partner Payment for MH12EF9012 - October 2025",
  "status": "reversed",
  "createdAt": "2025-11-10T09:00:00.000Z",
  "completedAt": "2025-11-10T09:00:00.000Z",
  "reversedAt": "2025-11-15T11:00:00.000Z"
}
```

### Field Validation Rules
- `id`: Auto-generated by Firestore, never set manually
- `vehicleId`: Must match existing vehicle document ID
- `type`: Must be one of the 5 allowed payment types
- `amount`: Must be positive number > 0
- `month`: Must follow period string format (YYYY-MM, YYYY-Q#, YYYY)
- `status`: Defaults to 'completed' for new payments
- `createdAt` & `completedAt`: ISO 8601 timestamp strings
- `reversedAt`: Only present when status is 'reversed'

### Query Patterns Used in Section 5

#### Find Paid Amount for Period
```javascript
const paidAmount = accountingTransactions
  .filter(t => 
    t.vehicleId === vehicleId && 
    t.type === paymentType && // 'gst_payment', etc.
    periodStrings.includes(t.month) && 
    t.status === 'completed'
  )
  .reduce((sum, t) => sum + t.amount, 0);
```

#### Find Transactions for Undo
```javascript
const transactionsToReverse = accountingTransactions.filter(t => 
  t.vehicleId === vehicleId && 
  t.type === paymentType && 
  periodStrings.includes(t.month) &&
  t.status === 'completed'
);
```

## Payment Algorithm for Section 5 - All Payments Follow the Same Pattern

**CRITICAL NOTE FOR AI IMPLEMENTATION**: All payment types (GST, Service Charge, Partner Payment, Owner's Share, Owner's Withdrawal) follow **EXACTLY THE SAME ALGORITHM**. The only difference is:
- The `type` field in the transaction ('gst_payment', 'service_charge', etc.)
- The calculation formula for the base amount
- The source field in `vehicleInfo` (gstAmount, serviceCharge, etc.)

The algorithm steps are identical for all payment types. Use GST as the example below, but apply the same steps to all payment types by changing only the type and amount source.

### Algorithm Steps (Same for All Payment Types)

#### Step 1: Get Period Data
```javascript
const periodData = getPeriodData(vehicleId);
const periodStrings = periodData.periodStrings; // ["2025-11"] for monthly, etc.
```

#### Step 2: Calculate Total Amount Due for Period
```javascript
// For GST (use appropriate formula for each payment type)
const totalAmountDue = vehicleInfo.gstAmount; // or serviceCharge, partnerShare, etc.

// This is the calculated amount for the entire period (sum of all months in period)
```

#### Step 3: Calculate Already Paid Amount
```javascript
const paidAmount = accountingTransactions
  .filter(t => 
    t.vehicleId === vehicleId && 
    t.type === 'gst_payment' && // changes per payment type
    periodStrings.includes(t.month) && 
    t.status === 'completed'
  )
  .reduce((sum, t) => sum + t.amount, 0);
```

#### Step 4: Calculate Actually Payable Amount
```javascript
const actuallyPayable = Math.max(0, totalAmountDue - paidAmount);
```

#### Step 5: Determine Button State
```javascript
const isEnabled = actuallyPayable > 0;
const buttonText = `Pay GST ₹${actuallyPayable.toLocaleString()}`; // changes per type
```

#### Step 6: Handle Payment (Same for All Types)
```javascript
const handlePayment = async (vehicleInfo, selectedMonths = null) => {
  // For individual buttons, selectedMonths is null (process entire period)
  // For bulk dialogs, selectedMonths contains user selection
  
  const monthsToProcess = selectedMonths || periodStrings;
  
  for (const monthStr of monthsToProcess) {
    // Calculate amount for this specific month
    const monthAmount = calculateMonthAmount(monthStr, vehicleInfo, paymentType);
    
    // Create transaction
    await createTransaction(vehicleId, paymentType, monthAmount, monthStr);
    
    // Update cash balances
    await updateCashBalances(vehicleId, -monthAmount);
  }
  
  // Update local state
  updateLocalState();
};
```

### Payment Flow Diagram

```
┌─────────────────┐
│   User Clicks   │
│ Payment Button  │
│ (Section 5)     │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐     ┌─────────────────┐
│ Get Period Data │────▶│ periodStrings[] │
│ (getPeriodData) │     │ ["2025-11"] etc │
└─────────┬───────┘     └─────────────────┘
          │
          ▼
┌─────────────────┐     ┌─────────────────┐
│ Calculate Total │────▶│ totalAmountDue  │
│ Amount Due      │     │ (gstAmount, etc)│
│ (Formula)       │     └─────────────────┘
└─────────┬───────┘
          │
          ▼
┌─────────────────┐     ┌─────────────────┐
│ Find Paid       │────▶│ paidAmount      │
│ Transactions    │     │ (from existing  │
│ (Filter by      │     │  transactions)  │
│  periodStrings) │     └─────────────────┘
└─────────┬───────┘
          │
          ▼
┌─────────────────┐     ┌─────────────────┐
│ Calculate       │────▶│ actuallyPayable │
│ Actually Payable│     │ MAX(0, total - │
│ Amount          │     │       paid)     │
└─────────┬───────┘     └─────────────────┘
          │
          ▼
┌─────────────────┐     ┌─────────────────┐
│ Button State    │────▶│ isEnabled:      │
│ (Enable/Disable)│     │ actuallyPayable │
│                 │     │ > 0             │
└─────────┬───────┘     └─────────────────┘
          │
     ┌────▼────┐
     │Enabled? │
     └────┬────┘
          │
    ┌─────┴─────┐
    │   YES    │     NO
    └─────┬────┘     │
          │          │
          ▼          ▼
┌─────────────────┐ ┌─────────────────┐
│ Show Dialog     │ │ Button Disabled │
│ (Confirm Amount)│ │ (Grayed Out)    │
└─────────┬───────┘ └─────────────────┘
          │
          ▼
┌─────────────────┐
│ User Confirms   │
│ Payment         │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Process Payment │
│ (Same for all   │
│ payment types)  │
│                 │
│ 1. Create       │
│    Transaction  │
│ 2. Update Cash  │
│    Balances     │
│ 3. Update Local │
│    State        │
└─────────────────┘
```

### Implementation Notes for All Payment Types

#### 1. Transaction Type Mapping
```javascript
const PAYMENT_TYPES = {
  gst: 'gst_payment',
  serviceCharge: 'service_charge', 
  partnerPayment: 'partner_payment',
  ownerShare: 'owner_share',
  ownerWithdrawal: 'owner_withdrawal'
};
```

#### 2. Amount Source Mapping
```javascript
const AMOUNT_SOURCES = {
  gst: 'gstAmount',
  serviceCharge: 'serviceCharge',
  partnerPayment: 'partnerShare', 
  ownerShare: 'ownerShare',
  ownerWithdrawal: 'ownerFullShare'
};
```

#### 3. Button Text Templates
```javascript
const BUTTON_TEXTS = {
  gst: 'Pay GST',
  serviceCharge: 'Withdraw Service Charge',
  partnerPayment: 'Pay Partner',
  ownerShare: 'Withdraw Owner Share',
  ownerWithdrawal: 'Withdraw Owner Amount'
};
```

#### 4. Status Badge Text
```javascript
const STATUS_TEXTS = {
  gst: 'GST Paid',
  serviceCharge: 'Service Charge Collected',
  partnerPayment: 'Partner Paid',
  ownerShare: 'Owner Share Collected', 
  ownerWithdrawal: 'Owner Withdrawn'
};
```

### Key Algorithm Principles

1. **Same Logic, Different Parameters**: All payments use identical filtering, calculation, and processing logic
2. **Period String Matching**: Always use `periodStrings.includes(t.month)` for consistency
3. **Atomic Operations**: All database updates use `increment()` for thread safety
4. **Local State Sync**: Always update local arrays and balances after database operations
5. **Error Handling**: Same error handling pattern for all payment types
6. **Undo Support**: All payments support reversal using the same undo algorithm

### Example Implementation (GST - Apply Same Pattern to All)

```typescript
// Generic payment handler (works for all types)
const handleGenericPayment = async (
  vehicleInfo: any, 
  paymentType: keyof typeof PAYMENT_TYPES,
  selectedMonths?: string[]
) => {
  try {
    const type = PAYMENT_TYPES[paymentType];
    const amountSource = AMOUNT_SOURCES[paymentType];
    const totalAmount = vehicleInfo[amountSource];
    
    // Same calculation logic as above
    const actuallyPayable = calculateActuallyPayable(vehicleInfo.vehicle.id, type);
    
    if (actuallyPayable <= 0) {
      throw new Error('No amount due');
    }
    
    // Same processing logic
    await processPayment(vehicleInfo, type, actuallyPayable, selectedMonths);
    
    // Update UI
    toast.success(`${BUTTON_TEXTS[paymentType]} processed successfully`);
    
  } catch (error) {
    console.error(`Error processing ${paymentType}:`, error);
    toast.error(`Failed to process ${BUTTON_TEXTS[paymentType]}`);
  }
};
```

**REMINDER**: The algorithm above applies to ALL payment types. Just change the `paymentType` parameter and the corresponding mappings. The core logic remains identical.

## Core Concepts

## Core Concepts

### Period Types & Period Strings
- **Monthly**: Single month (e.g., "2025-11") → periodStrings: ["2025-11"]
- **Quarterly**: 3 months (e.g., "2025-Q4" includes Oct, Nov, Dec) → periodStrings: ["2025-10", "2025-11", "2025-12"]
- **Yearly**: 12 months (e.g., "2025") → periodStrings: ["2025-01", "2025-02", ..., "2025-12"]

### Payment Tracking
All payments tracked in `accountingTransactions` collection with:
- `type`: 'gst_payment', 'service_charge', 'partner_payment', 'owner_share', 'owner_withdrawal'
- `month`: Period string from periodStrings[]
- `status`: 'completed' (paid), 'pending', 'reversed'
- `amount`: Payment amount

## Base Profit Calculation (Per Vehicle, Per Period)

```
Monthly Earnings = Σ(payments.amountPaid) for that month where status === 'paid'
Monthly Expenses = Σ(expenses.amount) for that month where status === 'approved'
Monthly Profit = Monthly Earnings - Monthly Expenses

Cumulative Earnings = Σ(Monthly Earnings) for all months in period
Cumulative Expenses = Σ(Monthly Expenses) for all months in period
Cumulative Profit = Cumulative Earnings - Cumulative Expenses
```

## Payment Type Calculations

### 1. GST Payment (4% to Government)
**Formula**: `GST = Cumulative Profit > 0 ? Cumulative Profit × 0.04 : 0`

### 2. Service Charge (Company Fee on Partner Vehicles)
**Formula**: `Service Charge = (isPartnerVehicle && Cumulative Profit > 0) ? Cumulative Profit × serviceChargeRate : 0`
**Where**: `serviceChargeRate = (vehicle.serviceChargeRate || 10) / 100`

### 3. Partner Share & Owner Payment (Profit Distribution)
**Remaining Profit**: `Remaining Profit = Cumulative Profit - GST - Service Charge`

**Partner Share**: `Partner Share = Remaining Profit × partnerPercentage` (if partner vehicle)
**Owner Payment**: `Owner Payment = Remaining Profit × (1 - partnerPercentage)` (if partner vehicle)
**Owner Payment**: `Owner Payment = Cumulative Profit - GST` (if company vehicle)

### 4. Owner Payment (Consolidated for All Vehicles)
**Formula**: `Owner Payment = vehicleInfo.ownerPayment` (unified calculation for both partner and company vehicles)

## Button Amount Calculation Cases

### Case 1: All Months Not Paid (Fresh Vehicle - No Prior Payments)

#### Monthly Selection (e.g., November 2025)
```
periodStrings = ["2025-11"]
Total GST = GST for November only
Paid GST Amount = 0 (no transactions found)
GST Button Amount = Total GST - 0 = Total GST

Same for all payment types:
- Service Charge Button = Total Service Charge
- Partner Payment Button = Total Partner Share  
- Owner's Share Button = Total Owner Share + Total Owner Full Share
- Owner's Withdrawal Button = Total Owner's Withdrawal
```

#### Quarterly Selection (e.g., Q4 2025: Oct, Nov, Dec)
```
periodStrings = ["2025-10", "2025-11", "2025-12"]
Total GST = Σ(GST for Oct + Nov + Dec)
Paid GST Amount = 0
GST Button Amount = Total GST

Same pattern for all payments - sum across all 3 months
```

#### Yearly Selection (e.g., 2025)
```
periodStrings = ["2025-01", "2025-02", ..., "2025-12"]
Total GST = Σ(GST for all 12 months)
Paid GST Amount = 0
GST Button Amount = Total GST

Same pattern for all payments - sum across all 12 months
```

### Case 2: Some Months Paid (Partial Payments)

#### Monthly Selection (e.g., November 2025, but November already paid)
```
periodStrings = ["2025-11"]
Total GST = GST for November
Paid GST Amount = Σ(amount) from accountingTransactions where:
  - vehicleId matches
  - type === 'gst_payment'
  - month === "2025-11"
  - status === 'completed'
GST Button Amount = MAX(0, Total GST - Paid GST Amount)

If Paid GST Amount >= Total GST → Button Amount = 0
If Paid GST Amount < Total GST → Button Amount = Total GST - Paid GST Amount
```

#### Quarterly Selection (e.g., Q4 2025, November paid, Oct & Dec not paid)
```
periodStrings = ["2025-10", "2025-11", "2025-12"]
Total GST = GST for Oct + GST for Nov + GST for Dec

Paid GST Amount = Σ(amount) from accountingTransactions where:
  - vehicleId matches
  - type === 'gst_payment' 
  - month in ["2025-10", "2025-11", "2025-12"]
  - status === 'completed'

GST Button Amount = MAX(0, Total GST - Paid GST Amount)

Example: If November GST = ₹800 already paid
Total GST = ₹2,400 (for 3 months)
Paid GST Amount = ₹800
GST Button Amount = ₹2,400 - ₹800 = ₹1,600 (Oct + Dec GST)
```

#### Yearly Selection (e.g., 2025, some months paid)
```
periodStrings = ["2025-01", ..., "2025-12"]
Total GST = Σ(GST for all 12 months)

Paid GST Amount = Σ(amount) from accountingTransactions where:
  - vehicleId matches
  - type === 'gst_payment'
  - month in periodStrings
  - status === 'completed'

GST Button Amount = MAX(0, Total GST - Paid GST Amount)
```

**Same logic applies to all payment types** - Service Charge, Partner Payment, Owner's Share, Owner's Withdrawal

### Case 3: All Months Paid (Fully Paid for Period)

#### Any Selection (Monthly/Quarterly/Yearly)
```
Total [Payment Type] = Calculated amount for period
Paid [Payment Type] Amount = Σ(amount) from accountingTransactions where:
  - vehicleId matches
  - type matches payment type
  - month in periodStrings
  - status === 'completed'

[Payment Type] Button Amount = MAX(0, Total [Payment Type] - Paid [Payment Type] Amount)

Since all months paid: Paid Amount >= Total Amount
Button Amount = 0 (button disabled/hidden)
```

## Section 5 Individual Vehicle Payment Buttons - Monthly View Logic

### Overview
This section documents the specific implementation for **individual vehicle payment buttons** in Section 5 of `FinancialAccountsTab.tsx` when **monthly view** is selected. Each vehicle card shows payment buttons based on per-month calculations and the most recent transaction status.

### GST Calculation for Single Month

#### Monthly GST Formula
When monthly period is selected (e.g., November 2025), GST is calculated as:
```
Monthly GST = (Monthly Profit > 0) ? Monthly Profit × 0.04 : 0

Where:
- Monthly Profit = Monthly Earnings - Monthly Expenses
- Monthly Earnings = Σ(payments.amountPaid) for the selected month where status === 'paid'
- Monthly Expenses = Σ(expenses.amount) for the selected month where status === 'approved'
```

#### Implementation in getPeriodData()
```javascript
// For monthly view, months array contains only 1 month
const months = [selectedMonthIndex]; // e.g., [10] for November

// Calculate cumulative data (which becomes monthly data for single month)
months.forEach(monthIndex => {
  // Calculate monthEarnings, monthExpenses for this month
  cumulativeEarnings += monthEarnings;
  cumulativeExpenses += monthExpenses;
});

cumulativeProfit = cumulativeEarnings - cumulativeExpenses;
cumulativeGst = cumulativeProfit > 0 ? cumulativeProfit * 0.04 : 0;
```

### Button Display Logic for Monthly View

#### Latest Transaction Status Check
For each payment type, the system finds the most recent transaction for the specific month:

```javascript
const getLatestTransactionStatus = (vehicleId: string, transactionType: string, monthStr: string) => {
  const relevantTransactions = accountingTransactions.filter((t: any) =>
    t.vehicleId === vehicleId &&
    t.type === transactionType &&
    t.month === monthStr
  );

  if (relevantTransactions.length === 0) return null;

  // Sort by completedAt descending to get most recent
  const sortedTransactions = relevantTransactions.sort((a, b) => {
    const aTime = a.completedAt ? new Date(a.completedAt).getTime() : 0;
    const bTime = b.completedAt ? new Date(b.completedAt).getTime() : 0;
    return bTime - aTime;
  });

  return sortedTransactions[0].status; // 'completed', 'reversed', or null
};
```

#### GST Button Display Cases

##### Case 1: GST Amount = 0
```
Condition: vehicleInfo.gstAmount <= 0
Display: Disabled "Pay GST" button with ₹0
Logic: No need to check accountingTransactions since GST was never calculated
```

##### Case 2: GST Amount > 0, No Transaction Found
```
Condition: vehicleInfo.gstAmount > 0 AND getLatestTransactionStatus() === null
Display: Enabled "Pay GST ₹{gstAmount.toLocaleString()}" button
Logic: GST calculated but never paid
```

##### Case 3: GST Amount > 0, Latest Transaction Status = 'completed'
```
Condition: vehicleInfo.gstAmount > 0 AND getLatestTransactionStatus() === 'completed'
Display: Green "Paid" badge with checkmark icon
Logic: Most recent transaction shows payment was completed
```

##### Case 4: GST Amount > 0, Latest Transaction Status = 'reversed'
```
Condition: vehicleInfo.gstAmount > 0 AND getLatestTransactionStatus() === 'reversed'
Display: Enabled "Pay GST ₹{gstAmount.toLocaleString()}" button
Logic: Payment was undone, user can pay again
```

#### Same Logic Applies to All Payment Types

**Service Charge Button:**
- Amount Source: `vehicleInfo.serviceCharge`
- Transaction Type: `'service_charge'`
- Button Text: `"Withdraw ₹{serviceCharge.toLocaleString()}"`
- Badge Text: `"Collected"`

**Partner Payment Button:**
- Amount Source: `vehicleInfo.partnerShare`
- Transaction Type: `'partner_payment'`
- Button Text: `"Pay Partner ₹{partnerShare.toLocaleString()}"`
- Badge Text: `"Paid"`

**Owner's Share Button:**
- Amount Source: `vehicleInfo.ownerShare`
- Transaction Type: `'owner_share'`
- Button Text: `"Withdraw ₹{ownerShare.toLocaleString()}"`
- Badge Text: `"Collected"`

**Owner's Withdrawal Button:**
- Amount Source: `vehicleInfo.ownerFullShare`
- Transaction Type: `'owner_withdrawal'`
- Button Text: `"Withdraw ₹{ownerFullShare.toLocaleString()}"`
- Badge Text: `"Withdrawn"`

### Confirmation Dialog Flow for Individual Payments

#### Dialog Trigger
- User clicks any enabled payment button in Section 5
- Dialog opens with confirmation details
- **No additional validation** - button enable/disable logic already handles all restrictions

#### Dialog Content
```javascript
// Example for GST Payment Dialog
const dialogContent = {
  title: `Confirm GST Payment`,
  description: `Pay GST for ${vehicleInfo.vehicle.vehicleName} - ${periodLabel} ${selectedYear}`,
  amount: vehicleInfo.gstAmount, // Same amount shown on button
  vehicle: vehicleInfo.vehicle,
  paymentType: 'gst_payment'
};
```

#### Dialog Validation
- **No amount validation** - uses exact amount from button
- **No cash balance checks** - assumes button enable logic prevents insufficient funds
- **No period restrictions** - single month payment for monthly view

#### Payment Processing
```javascript
const handleGstPayment = async (vehicleInfo: any) => {
  const monthStr = `${selectedYear}-${String(selectedMonth).padStart(2, '0')}`;
  const amount = vehicleInfo.gstAmount;

  // 1. Create transaction document
  const transactionRef = collection(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/accountingTransactions`);
  const docRef = await addDoc(transactionRef, {
    vehicleId: vehicleInfo.vehicle.id,
    type: 'gst_payment',
    amount: amount,
    month: monthStr,
    description: `GST Payment for ${vehicleInfo.vehicle.vehicleName} - ${periodLabel} ${selectedYear}`,
    status: 'completed',
    createdAt: new Date().toISOString(),
    completedAt: new Date().toISOString()
  });

  // 2. Update vehicle cash balance
  const cashRef = doc(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/cashInHand`, vehicleInfo.vehicle.id);
  await setDoc(cashRef, {
    balance: increment(-amount)
  }, { merge: true });

  // 3. Update company cash balance
  const companyCashRef = doc(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/companyCashInHand`, 'main');
  await setDoc(companyCashRef, {
    balance: increment(-amount),
    lastUpdated: new Date().toISOString()
  }, { merge: true });

  // 4. Update local state
  const newTransaction = {
    id: docRef.id,
    vehicleId: vehicleInfo.vehicle.id,
    type: 'gst_payment',
    amount: amount,
    month: monthStr,
    description: `GST Payment for ${vehicleInfo.vehicle.vehicleName} - ${periodLabel} ${selectedYear}`,
    status: 'completed',
    createdAt: new Date().toISOString(),
    completedAt: new Date().toISOString()
  };

  setAccountingTransactions(prev => [...prev, newTransaction]);
  setVehicleCashBalances(prev => ({
    ...prev,
    [vehicleInfo.vehicle.id]: (prev[vehicleInfo.vehicle.id] || 0) - amount
  }));

  // Close dialog and show success
  setConfirmGstPaymentDialog(false);
  toast.success('GST Payment completed successfully');
};
```

#### Key Principles for Section 5 Individual Payments

1. **Single Month Focus**: All calculations and transactions are for the selected month only
2. **Latest Transaction Priority**: Always check the most recent transaction status
3. **No Dialog Restrictions**: When button is enabled, dialog allows instant payment
4. **Atomic Operations**: All database updates use Firestore increment() for thread safety
5. **Immediate UI Updates**: Local state updated immediately for responsive UX
6. **Same Pattern for All Types**: GST, Service Charge, Partner Payment, Owner's Share, Owner's Withdrawal all follow identical logic

### Implementation Status
✅ **COMPLETED**: The FinancialAccountsTab.tsx has been updated to implement the exact logic described above for monthly view. The `getLatestTransactionStatus()` helper function has been added and all payment buttons (GST, Service Charge, Partner Payment, Owner's Share, Owner's Withdrawal) now use the latest transaction status for monthly view instead of checking if any transaction exists in the period.

## Payment Processing Flow

### 1. User Clicks Payment Button
- Button shows "Actually Payable" amount (after deductions)
- Opens confirmation dialog

### 2. Dialog Shows Month Selection (Quarterly/Yearly only)
- Lists all months in period
- Shows payment status for each month:
  - ✅ Paid (with amount and date)
  - ⏳ Unpaid (with calculated amount)
- User selects months to pay (unpaid months selected by default)
- Amount updates based on selection

### 3. Payment Confirmation
- Creates transaction document(s) in `accountingTransactions`:
  - One document per selected month
  - `month`: Individual month string (e.g., "2025-11")
  - `amount`: Payment amount for that month
  - `type`: Payment type
  - `status`: 'completed'

### 4. Database Operations (Per Transaction)
```
1. accountingTransactions Collection:
   - Path: Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/accountingTransactions
   - Operation: addDoc() - create new document

2. cashInHand Subcollection:
   - Path: Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/cashInHand/{vehicleId}
   - Operation: setDoc(..., { balance: increment(-amount) }, { merge: true })

3. companyCashInHand Collection:
   - Path: Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/companyCashInHand/main
   - Operation: setDoc(..., { balance: increment(-amount), lastUpdated: new Date() }, { merge: true })
```

### 5. Local State Updates
- Add new transaction to `accountingTransactions` array
- Update `vehicleCashBalances[vehicleId] -= totalAmount`
- Recalculate button amounts (should become 0 for paid months)

## Key Technical Implementation Notes

1. **Period String Matching**: Always use `periodStrings.includes(t.month)` for finding existing payments
2. **Atomic Updates**: All cash operations use `increment()` for thread safety
3. **Bulk Payments**: Create multiple transaction documents for quarterly/yearly selections
4. **Status Tracking**: Only `status === 'completed'` counts as paid
5. **Amount Deduction**: Button amount = MAX(0, calculated - paid) to prevent negative values

## Undo Process (Reverse Payment)
1. Find transaction(s) by vehicleId, type, periodStrings.includes(month), status === 'completed'
2. Update transaction status to 'reversed', add reversedAt timestamp
3. Increment cash balances by +originalAmount
4. Update local state: remove from accountingTransactions or mark as reversed

This flow ensures accurate profit distribution and payment tracking using only existing fields in the accountingTransactions collection.

### Document ID
- **Auto-generated** by Firestore using `addDoc()`
- Stored in the `id` field of the local state object

### Transaction Types by Button

| Button | Transaction Type | Amount Source |
|--------|------------------|---------------|
| GST Payment | `'gst_payment'` | `vehicleInfo.gstAmount` |
| Service Charge | `'service_charge'` | `vehicleInfo.serviceCharge` |
| Partner Payment | `'partner_payment'` | `vehicleInfo.partnerShare` |
| Owner's Share | `'owner_share'` | `vehicleInfo.ownerShare` |
| Owner's Withdrawal | `'owner_withdrawal'` | `vehicleInfo.ownerFullShare` |

## How Documents Are Added

### Firestore Operation
```javascript
const transactionRef = collection(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/accountingTransactions`);

const docRef = await addDoc(transactionRef, {
  vehicleId: vehicleInfo.vehicle.id,
  type: 'gst_payment', // varies by button
  amount: paymentAmount,
  month: monthStr, // period string
  description: paymentDescription,
  status: 'completed',
  createdAt: new Date().toISOString(),
  completedAt: new Date().toISOString()
});
```

### Local State Update
```javascript
const newTransaction = {
  id: docRef.id, // Firestore auto-generated ID
  vehicleId: vehicleInfo.vehicle.id,
  type: 'gst_payment',
  amount: paymentAmount,
  month: monthStr,
  description: paymentDescription,
  status: 'completed',
  createdAt: new Date().toISOString(),
  completedAt: new Date().toISOString()
};

setAccountingTransactions([...accountingTransactions, newTransaction]);
```

## Database Operations Per Button

Each button performs **exactly 3 database operations**:

### 1. accountingTransactions Collection
- **Path**: `Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/accountingTransactions`
- **Operation**: Creates **1 new document** with transaction details
- **Fields**: vehicleId, type, amount, month, description, status, createdAt, completedAt

### 2. cashInHand Subcollection
- **Path**: `Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/cashInHand/{vehicleId}`
- **Operation**: Updates **1 document** (vehicle-specific cash balance)
- **Update**: `balance` field using `increment(-amount)` (decreases cash)

### 3. companyCashInHand Collection
- **Path**: `Easy2Solutions/companyDirectory/tenantCompanies/{companyId}/companyCashInHand/main`
- **Operation**: Updates **1 document** (company-wide cash balance)
- **Update**: `balance` field using `increment(-amount)` and `lastUpdated` timestamp

## Total Impact Summary

### Individual Button Impact
- **3 collections** updated per button
- **3 documents** modified per button
- All operations are **cash outflows** (negative amounts)

### Combined Impact (All 4 Buttons)
- **3 collections** total (same for all buttons)
- **12 documents** updated across all buttons
- **12 database operations** total

## Undo Operations Required

For proper undo functionality, each payment must be reversed by:

### 1. Update Transaction Status
- Change `status` from `'completed'` to `'reversed'`
- Add `reversedAt` timestamp

### 2. Reverse Cash Balance Updates
- **cashInHand**: `increment(+originalAmount)` (add back the deducted amount)
- **companyCashInHand**: `increment(+originalAmount)` (add back the deducted amount)

### 3. Update Local State
- Update `accountingTransactions` array
- Update `vehicleCashBalances` state

## Key Technical Notes

- All operations use Firestore `increment()` for atomic updates
- Period strings must match between creation and lookup for undo to work
- Bulk payments create multiple transaction documents (one per month)
- Local state synchronization is critical for UI consistency

## Period String Logic

For undo to work correctly, period strings must be consistent:

- **Monthly**: `YYYY-MM` (e.g., "2025-01")
- **Quarterly**: `YYYY-Q#` (e.g., "2025-Q1")
- **Yearly**: `YYYY` (e.g., "2025")

The undo function uses `periodStrings.includes(t.month)` for matching, so all transaction creation must follow the same format.

## Bulk Payment Considerations

For quarterly/yearly periods with month selection:
- Multiple transactions created (one per selected month)
- Each transaction gets its own period string
- Undo must handle multiple transactions
- Cash amounts are divided by months in period

## Undo Implementation Code Template

If you forget the process, here's the exact code structure needed for undo functionality:

### Undo Function Signature
```typescript
const handleUndoPayment = async (vehicleInfo: any, paymentType: PaymentType) => {
  // 1. Get period strings for matching
  const periodData = getPeriodData(vehicleInfo.vehicle.id);
  const periodStrings = periodData.periodStrings;

  // 2. Find transaction(s) to reverse
  const transactionsToReverse = accountingTransactions.filter(t => 
    t.vehicleId === vehicleInfo.vehicle.id && 
    t.type === paymentType && 
    periodStrings.includes(t.month) &&
    t.status === 'completed'
  );

  if (transactionsToReverse.length === 0) {
    throw new Error('Transaction not found');
  }

  // 3. Reverse each transaction
  for (const transaction of transactionsToReverse) {
    // Update Firestore transaction status
    const transactionRef = doc(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/accountingTransactions`, transaction.id);
    await updateDoc(transactionRef, {
      status: 'reversed',
      reversedAt: new Date().toISOString()
    });

    // Reverse cash balances
    const cashRef = doc(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/cashInHand`, vehicleInfo.vehicle.id);
    await setDoc(cashRef, {
      balance: increment(transaction.amount) // Add back the amount
    }, { merge: true });

    const companyCashRef = doc(firestore, `Easy2Solutions/companyDirectory/tenantCompanies/${userInfo.companyId}/companyCashInHand`, 'main');
    await setDoc(companyCashRef, {
      balance: increment(transaction.amount), // Add back the amount
      lastUpdated: new Date().toISOString()
    }, { merge: true });
  }

  // 4. Update local state
  setAccountingTransactions(prev => prev.map(t => {
    if (transactionsToReverse.some(tr => tr.id === t.id)) {
      return { ...t, status: 'reversed' as const, reversedAt: new Date().toISOString() };
    }
    return t;
  }));

  setVehicleCashBalances(prev => ({
    ...prev,
    [vehicleInfo.vehicle.id]: (prev[vehicleInfo.vehicle.id] || 0) + totalReversedAmount
  }));
};
```

### Key Points to Remember:
1. **Filter transactions** using `periodStrings.includes(t.month)` for proper matching
2. **Loop through multiple transactions** for bulk payments
3. **Use increment(+amount)** to reverse the cash deductions
4. **Update status to 'reversed'** and add `reversedAt` timestamp
5. **Calculate total reversed amount** for local state updates

## Memory Recovery Checklist

If you forget the process, ask yourself:

1. **What collections are updated?** 
   - accountingTransactions (create document)
   - cashInHand (update balance) 
   - companyCashInHand (update balance)

2. **What needs to be reversed?**
   - Transaction status: 'completed' → 'reversed'
   - Cash balances: increment(+amount) to add money back
   - Local state: update arrays and balances

3. **How to find transactions to reverse?**
   - Match vehicleId, type, periodStrings.includes(month), status === 'completed'

4. **What fields are in accountingTransactions documents?**
   - vehicleId, type, amount, month, description, status, createdAt, completedAt, reversedAt

5. **What are the period string formats?**
   - Monthly: "2025-01", Quarterly: "2025-Q1", Yearly: "2025"

This documentation contains everything needed to implement undo functionality from scratch.

## Button Enable/Disable Logic

### Individual Vehicle Buttons (Per Vehicle Card) - MAIN FOCUS

**This is the primary flow for Section 5 individual vehicle payment buttons.** Each vehicle card in the FinancialAccountsTab shows these buttons based on the calculations below.

#### GST Payment Button
- **Enabled when**: `gstActuallyPayable > 0` (calculated profit GST minus already paid GST > 0)
- **Disabled when**: `gstActuallyPayable <= 0` (no GST due or already fully paid)
- **Display**: "Pay GST ₹{gstActuallyPayable.toLocaleString()}"
- **Status Badge**: Shows "Paid" when `gstPaid = true`

#### Service Charge Button (Partner Vehicles Only)
- **Enabled when**: `serviceCharge > 0` (calculated service charge amount > 0)
- **Disabled when**: `serviceCharge <= 0` (no service charge due)
- **Display**: "Withdraw ₹{serviceCharge.toLocaleString()}"
- **Status Badge**: Shows "Collected" when `serviceChargeCollected = true`

#### Partner Payment Button (Partner Vehicles Only)
- **Enabled when**: `partnerShare > 0` (calculated partner share > 0)
- **Disabled when**: `partnerShare <= 0` (no partner share due)
- **Display**: "Pay Partner ₹{partnerShare.toLocaleString()}"
- **Status Badge**: Shows "Paid" when `partnerPaid = true`

#### Owner's Share Button (Partner Vehicles Only)
- **Enabled when**: `ownerShare > 0` (calculated owner share > 0)
- **Disabled when**: `ownerShare <= 0` (no owner share due)
- **Display**: "Withdraw ₹{ownerShare.toLocaleString()}"
- **Status Badge**: Shows "Collected" when `ownerShareCollected = true`

#### Owner's Withdrawal Button (Company Vehicles Only)
- **Enabled when**: `ownerFullShare > 0` (calculated owner full share > 0)
- **Disabled when**: `ownerFullShare <= 0` (no owner withdrawal due)
- **Display**: "Withdraw ₹{ownerFullShare.toLocaleString()}"
- **Status Badge**: Shows "Withdrawn" when `ownerWithdrawn = true`

### Bulk Payment Buttons (Section 5 - Top Level)

**NOTE**: These are the bulk payment buttons at the top of Section 5 that operate across multiple vehicles. They use the same calculation logic as individual buttons but aggregate amounts across all vehicles. The main flow above focuses on individual vehicle buttons.

#### GST Bulk Button
- **Enabled when**: `actuallyPayable.gstActuallyPayable > 0` (sum of unpaid GST across all vehicles > 0)
- **Disabled when**: `actuallyPayable.gstActuallyPayable <= 0` (all GST paid for period)
- **Display**: "Pay GST (₹{actuallyPayable.gstActuallyPayable.toLocaleString()})"

#### Service Charge Bulk Button
- **Enabled when**: `actuallyPayable.serviceChargeActuallyPayable > 0`
- **Disabled when**: `actuallyPayable.serviceChargeActuallyPayable <= 0`
- **Display**: "Withdraw Service Charges (₹{actuallyPayable.serviceChargeActuallyPayable.toLocaleString()})"

#### Partner Share Bulk Button
- **Enabled when**: `actuallyPayable.partnerShareActuallyPayable > 0`
- **Disabled when**: `actuallyPayable.partnerShareActuallyPayable <= 0`
- **Display**: "Pay Partner Shares (₹{actuallyPayable.partnerShareActuallyPayable.toLocaleString()})"

#### Owner Share Bulk Button
- **Enabled when**: `actuallyPayable.ownerShareActuallyPayable > 0`
- **Disabled when**: `actuallyPayable.ownerShareActuallyPayable <= 0`
- **Display**: "Withdraw Owner Share (₹{actuallyPayable.ownerShareActuallyPayable.toLocaleString()})"

### Payment Status Flags

#### How Status is Determined
```javascript
// For each vehicle in periodData
gstPaid = periodStrings.some(periodStr => 
  accountingTransactions.some(t => 
    t.vehicleId === vehicleInfo.vehicle.id && 
    t.type === 'gst_payment' && 
    t.month === periodStr && 
    t.status === 'completed'
  )
);

// Same logic for serviceChargeCollected, partnerPaid, ownerShareCollected, ownerWithdrawn
```

#### Actually Payable Calculation
```javascript
gstActuallyPayable = Math.max(0, vehicleInfo.gstAmount - paidGstAmount);

// Where paidGstAmount is sum of all matching transactions
paidGstAmount = accountingTransactions
  .filter(t => t.vehicleId === vehicleInfo.vehicle.id && 
           t.type === 'gst_payment' && 
           periodStrings.includes(t.month) && 
           t.status === 'completed')
  .reduce((sum, t) => sum + t.amount, 0);
```

### Period-Specific Behavior

#### Monthly Selection
- **Period Strings**: `["2025-11"]` (single month)
- **Button Amounts**: Calculated for that specific month only
- **Status Check**: Checks transactions for that month string
- **Bulk Dialog**: Shows month selection (only 1 month, pre-selected)

#### Quarterly Selection (e.g., Q4 2025)
- **Period Strings**: `["2025-10", "2025-11", "2025-12"]`
- **Button Amounts**: Sum of calculations for all 3 months
- **Status Check**: Checks if ANY month has transactions (partial payment allowed)
- **Bulk Dialog**: Shows month selection checkboxes (unpaid months pre-selected)

#### Yearly Selection (2025)
- **Period Strings**: `["2025-01", "2025-02", ..., "2025-12"]`
- **Button Amounts**: Sum of calculations for all 12 months
- **Status Check**: Checks if ANY month has transactions
- **Bulk Dialog**: Shows month selection checkboxes (unpaid months pre-selected)

### Button Visibility Rules

#### Role-Based Visibility
- **Partner Role**: Cannot see any payment buttons (role !== Role.PARTNER condition)
- **Admin/Owner Role**: Can see all buttons based on vehicle type

#### Vehicle Type Visibility
- **GST Payment**: Always shown for non-partner users
- **Service Charge**: Only for partner vehicles (`isPartnership === true`)
- **Partner Payment**: Only for partner vehicles (`isPartnership === true`)
- **Owner's Share**: Only for partner vehicles (`isPartnership === true`)
- **Owner's Withdrawal**: Only for company vehicles (`isPartnership !== true`)

### Dialog Behavior

#### Individual Vehicle Dialogs
- **Confirmation Required**: Yes, shows amount and description
- **Month Selection**: No (processes for entire period)
- **Payment Processing**: Creates single transaction per period type

#### Bulk Payment Dialogs
- **Vehicle Selection**: Shows all eligible vehicles with checkboxes
- **Month Selection**: For quarterly/yearly periods, shows month checkboxes
- **Payment Processing**: Creates multiple transactions (one per selected month per vehicle)

## Summary: Section 5 Individual Vehicle Button Flow

This documentation primarily describes the payment calculation and button logic for **individual vehicle payment buttons** that appear on each vehicle card in Section 5 of `FinancialAccountsTab.tsx`. 

**Key Points for AI Implementation:**
1. Each vehicle card calculates its own payment amounts using `getPeriodData()`
2. Buttons are enabled when `actuallyPayable > 0` for that specific vehicle
3. Status badges show when payments are completed for that vehicle
4. Individual dialogs handle single vehicle payments
5. Bulk buttons at the top aggregate across all vehicles but follow similar logic

The main implementation focus should be on the individual vehicle button calculations and state management as described in the "Individual Vehicle Buttons" section above.
